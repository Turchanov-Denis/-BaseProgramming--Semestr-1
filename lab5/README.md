Лабораторная Работа №5 по курсу Языки программирования для 1ПМ
Заданы координаты N вершин на плоскости в произвольном порядке, не
обязательно целочисленные. Необходимо обойти их по часовой стрелке,
вернувшись в ту же вершину, так чтобы полученная фигура не имела
самопересечений, и вычислить периметр полученного многоугольника.
Многоугольник может получиться невыпуклым. Входные данные:
одномерный массив координат вершин, в котором координаты задаются
парой чисел с соседними индексами, например, float coord[]={0,0,1,0,0,1}
задает треугольник с координатами вершин A(0,0) B(1,0) C(0,1). Требуется
написать функцию с сигнатурой «float traverse_clockwise(float coord[],int n)»,
где coord - массив координат вершин, а n - число вершин (то есть
размерность массива равна 2*n) , которая обходит вершины по часовой
стрелке и возвращает длину периметра. Необходимо продемонстрировать
работу программы на 3-х примерах: 1) прямоугольник 2) звезда 3) почти
правильный 9-угольник. Все вершины задаются в произвольном порядке.
Представление координат, указанное выше требуется только для головной
функции traverse_clockwise. Внутреннее представление может быть любым,
удобным для работы. Количество вершин в фигуре не более 50.
Обращаю ваше внимание, что вершины заданы в произвольном порядке и
если их обходить в порядке следования, то получится фигура с
самопересечениями. Для решения задачи возможно придется погуглить что-
то вроде «обход вершин по часовой стрелке». Итак, нужно вычислить
значения функции traverse_clockwise для следующих фигур:
1) float rect[] = {1,5,7,1,7,5,1,1};
2) float star[] = {3.97, 0.82, 2.26, 3.69, 5.39, 2.16, 2.03, 2.11, 5.36, 4.06};
3) float enneagon[] ={ 76, 67.1, -8.3, 18, 55, 93.3, 77, 33, 21.3, 99, -20, 50, -
8.3, 82, 55, 6.7, 21.3, 0.76};
Для первой фигуры периметр можно легко вычислить в уме, третья фигура
задает почти правильный девятиугольник, вписанный в окружность
радиусом 50, и формулу периметра можно легко найти в интернете. Вторая
фигура – это звезда неправильной формы. Первую и третью фигуру можно
использовать для оценки правильности работы своей программы.